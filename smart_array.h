
/*
Шаблон класса SmartArray
*/
template<class Type>
class SmartArray
{
private: 

	unsigned int size_; // Количество элементов.
	Type* ptr_;		    // Указатель на блок выделенной динамической памяти под элементы массива.

public: 

	// Конструктор без параметров
	SmartArray(void) : ptr_(0), size_(0)
	{
	}

	// Конструктор, принимающий указатель на массив начальных значений и его длину.
	SmartArray(Type const *mas_ptr, unsigned int mas_size)
	{
		ptr_ = new Type[mas_size];  // Выделяем динамическую память для хранения элементов массива
		size_ = mas_size;		    // Сохраняем количество элементов 

		for (unsigned int i = 0; i<size_; i++) {
			ptr_[i] = mas_ptr[i];   // Копируем элементы переданного массива
		}
	}

	// Конструктор копирования.
	// Важно! По умолчанию будет создан конструктор копирования, выполняющий поэлементное копирование полей.
	// Для класса SmartArray это означает, что выделенная памть может быть очищена дважды, что приведет к ошибке.
	SmartArray(const SmartArray& src)
	{
		ptr_ = new Type[src.size()];  // Выделяем динамическую память для хранения элементов массива
		size_ = src.size();		      // Сохраняем количество элементов 

		for (unsigned int i = 0; i<size_; i++) {
			ptr_[i] = src[i];        // Копируем элементы переданного массива
		}
	}

	// Деструктор класса. 
	// Вызывается автоматически когда объект класса выходит из области видимости.
	// Используется для освобождения ресурсов, занятых объектом класса.
	// В случае класса SmartArray в деструкторе освобождается динамическая память, выделенная для хранения данных.
	~SmartArray(void)
	{
		delete [] ptr_;  // Освобождаем динамическую память если она была выделена
		// * Функция delete ничего не делает если ptr_ == 0
	}

	// Перегрузка оператора присваивания.
	// Важно! По умолчанию будет реализована операция присваивания, выполняющая поэлементное копирование полей.
	// Для класса SmartArray это означает, что выделенная памть может быть очищена дважды, что приведет к ошибке.
	SmartArray& operator = (const SmartArray& src)
	{
		if(&src == this) return *this; // Проверка на самоприсваивание

		ptr_ = new Type[src.size()];   // Выделяем динамическую память для хранения элементов массива
		size_ = src.size();		       // Сохраняем количество элементов 

		for (unsigned int i = 0; i<size_; i++) {
			ptr_[i] = src[i];         // Копируем элементы переданного массива
		}

		return *this;
	}

	// Перегрузка оператора индексирования.
	// Операция индексирования должна возвращать ссылку на элемент.
	Type& operator[] (int i)
	{
		if (ptr_ && i >= 0 && i < size_)
			return ptr_[i];

		throw std::out_of_range("SmartArray index.");
	}

	// Перегрузка оператора индексирования для случая константного объекта.
	// Возвращает константную ссылку, т.е. значение возвращяемого элемента невозможно изменить.
	const Type& operator[] (int i) const
	{
		if (ptr_ && i >= 0 && i < size_)
			return ptr_[i];

		throw std::out_of_range("SmartArray index.");
	}

	// Метод объекта. Возвращает размер массива.
	int size() const
	{
		return size_;
	}

	// Метод объекта. Добавляет элемент в конец массива.
	void pushBack(const Type& new_element)
	{
		// Пример приведен для наглядности. 
		// Выделение памяти при добавлении каждого элемента крайне неэффективно.

		Type* old_ptr = ptr_;

		ptr_ = new Type[size_ + 1]; // Выделение нового блока памяти под увеличевшееся количество элементов

		for (unsigned int i = 0; i<size_; i++) {
			ptr_[i] = old_ptr[i]; // Копирование значений всех текущих элементов
		}

		ptr_[size_++] = new_element; // Копирование добавленного значения

		delete [] old_ptr; // Освобождение ранее выделенного блока памяти
	}
};

// Переопределение оператора << класса std::ostream для вывода на консоль элементов массива SmartArray
template<class Type>
std::ostream& operator<<(std::ostream& o, const SmartArray<Type>& sa)
{
	o << '[';

	if( sa.size() > 0)
	{
		o << sa[0];
		for(int i=1; i<sa.size(); ++i) { o << ", " << sa[i]; }
	}

	o << ']';

	return o;
}
